import {
  require_is_graph
} from "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-layout-noverlap/iterate.js
var require_iterate = __commonJS({
  "node_modules/graphology-layout-noverlap/iterate.js"(exports, module) {
    var NODE_X = 0;
    var NODE_Y = 1;
    var NODE_SIZE = 2;
    var PPN = 3;
    function hashPair(a, b) {
      return a + "ยง" + b;
    }
    function jitter() {
      return 0.01 * (0.5 - Math.random());
    }
    module.exports = function iterate(options, NodeMatrix) {
      var margin = options.margin;
      var ratio = options.ratio;
      var expansion = options.expansion;
      var gridSize = options.gridSize;
      var speed = options.speed;
      var i, j, x, y, l, size;
      var converged = true;
      var length = NodeMatrix.length;
      var order = length / PPN | 0;
      var deltaX = new Float32Array(order);
      var deltaY = new Float32Array(order);
      var xMin = Infinity;
      var yMin = Infinity;
      var xMax = -Infinity;
      var yMax = -Infinity;
      for (i = 0; i < length; i += PPN) {
        x = NodeMatrix[i + NODE_X];
        y = NodeMatrix[i + NODE_Y];
        size = NodeMatrix[i + NODE_SIZE] * ratio + margin;
        xMin = Math.min(xMin, x - size);
        xMax = Math.max(xMax, x + size);
        yMin = Math.min(yMin, y - size);
        yMax = Math.max(yMax, y + size);
      }
      var width = xMax - xMin;
      var height = yMax - yMin;
      var xCenter = (xMin + xMax) / 2;
      var yCenter = (yMin + yMax) / 2;
      xMin = xCenter - expansion * width / 2;
      xMax = xCenter + expansion * width / 2;
      yMin = yCenter - expansion * height / 2;
      yMax = yCenter + expansion * height / 2;
      var grid = new Array(gridSize * gridSize), gridLength = grid.length, c;
      for (c = 0; c < gridLength; c++) grid[c] = [];
      var nxMin, nxMax, nyMin, nyMax;
      var xMinBox, xMaxBox, yMinBox, yMaxBox;
      var col, row;
      for (i = 0; i < length; i += PPN) {
        x = NodeMatrix[i + NODE_X];
        y = NodeMatrix[i + NODE_Y];
        size = NodeMatrix[i + NODE_SIZE] * ratio + margin;
        nxMin = x - size;
        nxMax = x + size;
        nyMin = y - size;
        nyMax = y + size;
        xMinBox = Math.floor(gridSize * (nxMin - xMin) / (xMax - xMin));
        xMaxBox = Math.floor(gridSize * (nxMax - xMin) / (xMax - xMin));
        yMinBox = Math.floor(gridSize * (nyMin - yMin) / (yMax - yMin));
        yMaxBox = Math.floor(gridSize * (nyMax - yMin) / (yMax - yMin));
        for (col = xMinBox; col <= xMaxBox; col++) {
          for (row = yMinBox; row <= yMaxBox; row++) {
            grid[col * gridSize + row].push(i);
          }
        }
      }
      var cell;
      var collisions = /* @__PURE__ */ new Set();
      var n1, n2, x1, x2, y1, y2, s1, s2, h;
      var xDist, yDist, dist, collision;
      for (c = 0; c < gridLength; c++) {
        cell = grid[c];
        for (i = 0, l = cell.length; i < l; i++) {
          n1 = cell[i];
          x1 = NodeMatrix[n1 + NODE_X];
          y1 = NodeMatrix[n1 + NODE_Y];
          s1 = NodeMatrix[n1 + NODE_SIZE];
          for (j = i + 1; j < l; j++) {
            n2 = cell[j];
            h = hashPair(n1, n2);
            if (gridLength > 1 && collisions.has(h)) continue;
            if (gridLength > 1) collisions.add(h);
            x2 = NodeMatrix[n2 + NODE_X];
            y2 = NodeMatrix[n2 + NODE_Y];
            s2 = NodeMatrix[n2 + NODE_SIZE];
            xDist = x2 - x1;
            yDist = y2 - y1;
            dist = Math.sqrt(xDist * xDist + yDist * yDist);
            collision = dist < s1 * ratio + margin + (s2 * ratio + margin);
            if (collision) {
              converged = false;
              n2 = n2 / PPN | 0;
              if (dist > 0) {
                deltaX[n2] += xDist / dist * (1 + s1);
                deltaY[n2] += yDist / dist * (1 + s1);
              } else {
                deltaX[n2] += width * jitter();
                deltaY[n2] += height * jitter();
              }
            }
          }
        }
      }
      for (i = 0, j = 0; i < length; i += PPN, j++) {
        NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;
        NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;
      }
      return { converged };
    };
  }
});

// node_modules/graphology-layout-noverlap/helpers.js
var require_helpers = __commonJS({
  "node_modules/graphology-layout-noverlap/helpers.js"(exports) {
    var PPN = 3;
    exports.validateSettings = function(settings) {
      if ("gridSize" in settings && typeof settings.gridSize !== "number" || settings.gridSize <= 0)
        return { message: "the `gridSize` setting should be a positive number." };
      if ("margin" in settings && typeof settings.margin !== "number" || settings.margin < 0)
        return {
          message: "the `margin` setting should be 0 or a positive number."
        };
      if ("expansion" in settings && typeof settings.expansion !== "number" || settings.expansion <= 0)
        return { message: "the `expansion` setting should be a positive number." };
      if ("ratio" in settings && typeof settings.ratio !== "number" || settings.ratio <= 0)
        return { message: "the `ratio` setting should be a positive number." };
      if ("speed" in settings && typeof settings.speed !== "number" || settings.speed <= 0)
        return { message: "the `speed` setting should be a positive number." };
      return null;
    };
    exports.graphToByteArray = function(graph, reducer) {
      var order = graph.order;
      var matrix = new Float32Array(order * PPN);
      var j = 0;
      graph.forEachNode(function(node, attr) {
        if (typeof reducer === "function") attr = reducer(node, attr);
        matrix[j] = attr.x;
        matrix[j + 1] = attr.y;
        matrix[j + 2] = attr.size || 1;
        j += PPN;
      });
      return matrix;
    };
    exports.assignLayoutChanges = function(graph, NodeMatrix, reducer) {
      var i = 0;
      graph.forEachNode(function(node) {
        var pos = {
          x: NodeMatrix[i],
          y: NodeMatrix[i + 1]
        };
        if (typeof reducer === "function") pos = reducer(node, pos);
        graph.mergeNodeAttributes(node, pos);
        i += PPN;
      });
    };
    exports.collectLayoutChanges = function(graph, NodeMatrix, reducer) {
      var positions = {};
      var i = 0;
      graph.forEachNode(function(node) {
        var pos = {
          x: NodeMatrix[i],
          y: NodeMatrix[i + 1]
        };
        if (typeof reducer === "function") pos = reducer(node, pos);
        positions[node] = pos;
        i += PPN;
      });
      return positions;
    };
    exports.createWorker = function createWorker(fn) {
      var xURL = window.URL || window.webkitURL;
      var code = fn.toString();
      var objectUrl = xURL.createObjectURL(
        new Blob(["(" + code + ").call(this);"], { type: "text/javascript" })
      );
      var worker = new Worker(objectUrl);
      xURL.revokeObjectURL(objectUrl);
      return worker;
    };
  }
});

// node_modules/graphology-layout-noverlap/defaults.js
var require_defaults = __commonJS({
  "node_modules/graphology-layout-noverlap/defaults.js"(exports, module) {
    module.exports = {
      gridSize: 20,
      margin: 5,
      expansion: 1.1,
      ratio: 1,
      speed: 3
    };
  }
});

// node_modules/graphology-layout-noverlap/index.js
var require_graphology_layout_noverlap = __commonJS({
  "node_modules/graphology-layout-noverlap/index.js"(exports, module) {
    var isGraph = require_is_graph();
    var iterate = require_iterate();
    var helpers = require_helpers();
    var DEFAULT_SETTINGS = require_defaults();
    var DEFAULT_MAX_ITERATIONS = 500;
    function abstractSynchronousLayout(assign, graph, params) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-noverlap: the given graph is not a valid graphology instance."
        );
      if (typeof params === "number") params = { maxIterations: params };
      else params = params || {};
      var maxIterations = params.maxIterations || DEFAULT_MAX_ITERATIONS;
      if (typeof maxIterations !== "number" || maxIterations <= 0)
        throw new Error(
          "graphology-layout-force: you should provide a positive number of maximum iterations."
        );
      var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings), validationError = helpers.validateSettings(settings);
      if (validationError)
        throw new Error("graphology-layout-noverlap: " + validationError.message);
      var matrix = helpers.graphToByteArray(graph, params.inputReducer), converged = false, i;
      for (i = 0; i < maxIterations && !converged; i++)
        converged = iterate(settings, matrix).converged;
      if (assign) {
        helpers.assignLayoutChanges(graph, matrix, params.outputReducer);
        return;
      }
      return helpers.collectLayoutChanges(graph, matrix, params.outputReducer);
    }
    var synchronousLayout = abstractSynchronousLayout.bind(null, false);
    synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
    module.exports = synchronousLayout;
  }
});
export default require_graphology_layout_noverlap();
//# sourceMappingURL=graphology-layout-noverlap.js.map
