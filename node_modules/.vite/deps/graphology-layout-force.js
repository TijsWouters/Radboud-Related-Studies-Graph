import {
  require_defaults
} from "./chunk-HGZQWRJC.js";
import {
  require_getters
} from "./chunk-ZK7RLJLY.js";
import {
  require_is_graph
} from "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-layout-force/iterate.js
var require_iterate = __commonJS({
  "node_modules/graphology-layout-force/iterate.js"(exports, module) {
    var {
      createNodeValueGetter,
      createEdgeValueGetter
    } = require_getters();
    module.exports = function iterate(graph, nodeStates, params) {
      const { nodeXAttribute: xKey, nodeYAttribute: yKey } = params;
      const { attraction, repulsion, gravity, inertia, maxMove } = params.settings;
      let { shouldSkipNode, shouldSkipEdge, isNodeFixed } = params;
      isNodeFixed = createNodeValueGetter(isNodeFixed);
      shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);
      shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);
      const nodes = graph.filterNodes((n, attr) => {
        return !shouldSkipNode.fromEntry(n, attr);
      });
      const adjustedOrder = nodes.length;
      for (let i = 0; i < adjustedOrder; i++) {
        const n = nodes[i];
        const attr = graph.getNodeAttributes(n);
        const nodeState = nodeStates[n];
        if (!nodeState)
          nodeStates[n] = {
            dx: 0,
            dy: 0,
            x: attr[xKey] || 0,
            y: attr[yKey] || 0
          };
        else
          nodeStates[n] = {
            dx: nodeState.dx * inertia,
            dy: nodeState.dy * inertia,
            x: attr[xKey] || 0,
            y: attr[yKey] || 0
          };
      }
      if (repulsion)
        for (let i = 0; i < adjustedOrder; i++) {
          const n1 = nodes[i];
          const n1State = nodeStates[n1];
          for (let j = i + 1; j < adjustedOrder; j++) {
            const n2 = nodes[j];
            const n2State = nodeStates[n2];
            const dx = n2State.x - n1State.x;
            const dy = n2State.y - n1State.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
            const repulsionX = repulsion / distance * dx;
            const repulsionY = repulsion / distance * dy;
            n1State.dx -= repulsionX;
            n1State.dy -= repulsionY;
            n2State.dx += repulsionX;
            n2State.dy += repulsionY;
          }
        }
      if (attraction)
        graph.forEachEdge(
          (edge, attr, source, target, sourceAttr, targetAttr, undirected) => {
            if (source === target) return;
            if (shouldSkipNode.fromEntry(source, sourceAttr) || shouldSkipNode.fromEntry(target, targetAttr))
              return;
            if (shouldSkipEdge.fromEntry(
              edge,
              attr,
              source,
              target,
              sourceAttr,
              targetAttr,
              undirected
            ))
              return;
            const n1State = nodeStates[source];
            const n2State = nodeStates[target];
            const dx = n2State.x - n1State.x;
            const dy = n2State.y - n1State.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
            const attractionX = attraction * distance * dx;
            const attractionY = attraction * distance * dy;
            n1State.dx += attractionX;
            n1State.dy += attractionY;
            n2State.dx -= attractionX;
            n2State.dy -= attractionY;
          }
        );
      if (gravity)
        for (let i = 0; i < adjustedOrder; i++) {
          const n = nodes[i];
          const nodeState = nodeStates[n];
          const { x, y } = nodeState;
          const distance = Math.sqrt(x * x + y * y) || 1;
          nodeStates[n].dx -= x * gravity * distance;
          nodeStates[n].dy -= y * gravity * distance;
        }
      const converged = false;
      for (let i = 0; i < adjustedOrder; i++) {
        const n = nodes[i];
        const nodeState = nodeStates[n];
        const distance = Math.sqrt(
          nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy
        );
        if (distance > maxMove) {
          nodeState.dx *= maxMove / distance;
          nodeState.dy *= maxMove / distance;
        }
        if (!isNodeFixed.fromGraph(graph, n)) {
          nodeState.x += nodeState.dx;
          nodeState.y += nodeState.dy;
          nodeState.fixed = false;
        } else {
          nodeState.fixed = true;
        }
      }
      return { converged };
    };
  }
});

// node_modules/graphology-layout-force/helpers.js
var require_helpers = __commonJS({
  "node_modules/graphology-layout-force/helpers.js"(exports) {
    exports.assignLayoutChanges = function(graph, nodeStates, params) {
      const { nodeXAttribute: x, nodeYAttribute: y } = params;
      graph.updateEachNodeAttributes(
        (n, attr) => {
          const state = nodeStates[n];
          if (!state || state.fixed) return attr;
          attr[x] = state.x;
          attr[y] = state.y;
          return attr;
        },
        { attributes: ["x", "y"] }
      );
    };
    exports.collectLayoutChanges = function(nodeStates) {
      const mapping = {};
      for (const n in nodeStates) {
        const state = nodeStates[n];
        mapping[n] = { x: state.x, y: state.y };
      }
      return mapping;
    };
  }
});

// node_modules/graphology-layout-force/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/graphology-layout-force/defaults.js"(exports, module) {
    module.exports = {
      nodeXAttribute: "x",
      nodeYAttribute: "y",
      isNodeFixed: "fixed",
      shouldSkipNode: null,
      shouldSkipEdge: null,
      settings: {
        attraction: 5e-4,
        repulsion: 0.1,
        gravity: 1e-4,
        inertia: 0.6,
        maxMove: 200
      }
    };
  }
});

// node_modules/graphology-layout-force/index.js
var require_graphology_layout_force = __commonJS({
  "node_modules/graphology-layout-force/index.js"(exports, module) {
    var isGraph = require_is_graph();
    var resolveDefaults = require_defaults();
    var iterate = require_iterate();
    var helpers = require_helpers();
    var DEFAULTS = require_defaults2();
    function abstractSynchronousLayout(assign, graph, params) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-force: the given graph is not a valid graphology instance."
        );
      if (typeof params === "number") params = { maxIterations: params };
      else params = params || {};
      const maxIterations = params.maxIterations;
      params = resolveDefaults(params, DEFAULTS);
      if (typeof maxIterations !== "number" || maxIterations <= 0)
        throw new Error(
          "graphology-layout-force: you should provide a positive number of maximum iterations."
        );
      const nodeStates = {};
      let result = null;
      let i;
      for (i = 0; i < maxIterations; i++) {
        result = iterate(graph, nodeStates, params);
        if (result.converged) break;
      }
      if (assign) {
        helpers.assignLayoutChanges(graph, nodeStates, params);
        return;
      }
      return helpers.collectLayoutChanges(nodeStates);
    }
    var synchronousLayout = abstractSynchronousLayout.bind(null, false);
    synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
    module.exports = synchronousLayout;
  }
});
export default require_graphology_layout_force();
//# sourceMappingURL=graphology-layout-force.js.map
